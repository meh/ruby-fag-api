#! /usr/bin/env ruby
# encoding: utf-8
require 'optparse'
require 'tempfile'
require 'colorb'
require 'stty'
require 'yaml'
require 'fag'

$options = {}

OptionParser.new do |o|
	$options[:config] = File.expand_path('~/.fagrc')
	$options[:show]   = :home

	$options[:colors] = {
		separator:    'black.bold',
		registered:   'blue.bold',
		unregistered: 'blue',
		tag:          'red',
		id:           'white.bold',
		text:         '',
		title:        '',
		quote:        'green'
	}

	o.on '-C', '--config PATH', 'the configuration file to use' do |value|
		$options[:config] = File.expand_path(value)
	end

	o.on '-U', '--url URL', 'the URL to the zdreN backend' do |value|
		$options[:url] = value
	end

	o.on '-n', '--name NAME', 'the username to log in with' do |value|
		$options[:name] = value
	end

	o.on '-p', '--password PASSWORD', 'the password to log in with' do |value|
		$options[:password] = value
	end

	o.on '-r', '--register', 'use passed NAME and PASSWORD to signup' do
		$options[:register] = true
	end

	o.on '-a', '--anonymous', 'force anonymous name even if password is given' do
		$options[:anonymous] = true
	end

	o.on '-b', '--bare', 'output without giggles' do
		$options[:bare] = true
	end

	o.on '-d', '--delete WHAT', 'flow id to delete' do |value|
		whole, type, id = value.match(/^(?:(.*?):)?(\d+)$/).to_a

		$options[:delete]    = type ? type.downcase.to_sym : :flow
		$options[:delete_id] = id.to_i
	end

	o.on '-s', '--show WHAT', 'select what flows to show' do |value|
		$options[:show] = value
	end

	o.on '-N', '--new', 'create a new flow' do
		$options[:new] = true
	end

	o.on '-f', '--for WHAT', 'for what is the drop' do |value|
		whole, type, id = value.match(/^(?:(.*?):)?(\d+)$/).to_a

		$options[:for]    = type ? type.downcase.to_sym : :flow
		$options[:for_id] = id.to_i
	end

	o.on '-t', '--title TITLE', 'the title' do |value|
		$options[:title] = value
	end

	o.on '-T', '--tags TAGS', Array, 'the tags to use' do |value|
		$options[:tags] = value
	end

	o.on '-c', '--content CONTENT', 'the content' do |value|
		$options[:content] = value
	end
end.parse!

$config = YAML.parse_file($options[:config]).transform rescue {}

unless $options[:name]
	$options[:name] = $config['name']
end

unless $options[:password]
	$options[:password] = $config['password']
end

unless $options[:url]
	$options[:url] = $config['url'] || 'http://fag2.herokuapp.com'
end

if $options[:anonymous]
	$options[:password] = false
end

if $config['colors']
	$config['colors'].each {|name, value|
		$options[:colors][name.downcase.to_sym] = value
	}
end

module Kernel
	STDIN.extend(STTY)

	def echo (text)
		text.strip.lines.each {|line|
			$stdout.puts line.strip
		}
	end

	def info (text)
		text.strip.lines.each {|line|
			$stdout.puts "#{'*'.green.bold} #{line.strip}"
		}
	end

	def warn (text)
		text.strip.lines.each {|line|
			$stdout.puts "#{'*'.yellow.bold} #{line.strip}"
		}
	end

	def fatal (text)
		text.strip.lines.each {|line|
			$stdout.puts "#{'*'.red} #{line.strip}"
		}
	end

	def added (text)
		text.strip.lines.each {|line|
			$stdout.puts "#{'+'.green} #{line.strip}"
		}
	end

	def deleted (text)
		text.strip.lines.each {|line|
			$stdout.puts "#{'-'.red} #{line.strip}"
		}
	end

	def confirm? (query, default = true)
		$stdout.print "#{??.white.bold} #{query} [#{default ? 'YES/no' : 'yes/NO'}] "

		case $stdin.gets.strip
			when /^(true|y(es)?|1)$/i then true
			when /^(false|no?|0)$/i   then false
			else                           !!default
		end
	end

	def choice (list = nil, query = 'The choice is yours')
		array = if list.is_a?(Array)
			list = Hash[list.each_with_index.map {|v, i|
				[i + 1, v]
			}]

			true
		else
			false
		end

		if list.is_a?(Hash)
			list = Hash[list.map {|i, v| [i.to_s, v] }]
		else
			return nil
		end

		max = list.keys.map {|x|
			x.to_s.size
		}.max

		$stdout.puts "#{query}:"
		list.each {|index, value|
			$stdout.puts "  #{index.rjust(max)}: #{value}"
		}
		$stdout.print "Choice: "

		choice = $stdin.gets.strip

		if list.keys.include?(choice)
			array ? choice.to_i - 1 : choice
		else
			nil
		end
	end

	def escape (what)
		what.to_s.gsub(/[\f\e\b\a]/) { |r| r.inspect[1 .. -2] }
	end

	def no_colors?
		!!ENV['NO_COLORS']
	end

	def color (what, type)
		result = what.to_s

		return result unless $options[:colors][type]

		$options[:colors][type].split(?.).each {|name|
			result = result.__send__ name
		}

		result
	end

	def color_author (author)
		color(escape(author), author.is_a?(Fag::User) ? :registered : :unregistered)
	end

	def vertical_separator
		no_colors? ? '|' : '│'
	end

	def angle_separator (side, side2)
		if side == :bottom
			if side2 == :left
				no_colors? ? '`' : '└'
			end
		end
	end

	def horizontal_separator
		no_colors? ? '-' : '─'
	end

	def middle_separator (side)
		if side == :top
			no_colors? ? "'" : '┴'
		end
	end

	def horz
		color(horizontal_separator, :separator)
	end

	def vert
		color(vertical_separator, :separator)
	end

	def mid
		color(middle_separator(:top), :separator)
	end

	def truncate (string, length)
		string.sub(/^(.{#{length - 4}})(.*)$/) { $2 ? $1 + '...' : $1 }
	end

	def print_flow (flow, bare = false)
		left_length = STDIN.cols - (flow.id.to_s.length + 2 + flow.tags.join(', ').length + 2 + flow.author.to_s.length + 2 + 3)

		unless bare
			puts " #{color(flow.id, :id)} #{vert} #{flow.tags.map { |t| color(t, :tag) }.join ', '} #{vert} #{color_author(flow.author)} #{vert} #{color(truncate(escape(flow.title), left_length), :title)}"
			print horz * (flow.id.to_s.length + 2) + mid
			print horz * (flow.tags.join(', ').length + 2) + mid
			print horz * (escape(flow.author).length + 2) + mid
			print horz * left_length
			puts "\n\n"
		end
	end

	def print_drop (drop, bare = false)
		unless bare
			if drop.relative_id
				left_length = STDIN.cols - (1 + escape(drop.author).length + (drop.title ? 3 + escape(drop.title).length : 0))

				print " #{color_author(drop.author)}#{" #{vert} #{color(escape(drop.title), :title)}" if drop.title}"
				print " " * (left_length - drop.relative_id.to_s.length - 3)
				puts "#{vert} #{color(drop.relative_id, :id)} "

				print (horz * (STDIN.cols - drop.relative_id.to_s.length - 3)).black.bold
				print mid
				puts horz * (drop.relative_id.to_s.length + 2)

			else
				puts " #{color_author(drop.author)}#{" #{vert} #{color(escape(drop.title), :title)}" if drop.title}"
				puts horz * STDIN.cols
			end

			puts escape(drop.content).gsub(/^>.*$/) { |rep| rep.green }
			puts ""
		else
			puts escape(drop.content)
		end
	end
end

$session = Fag::Session.new($options[:url])

unless $session.up?
	fatal "#{$session.url} seems to be down"
	exit 99
end

if $options[:register]
	begin
		$session.signup($options[:name], $options[:password])

		info 'registered succesfully'
	rescue Fag::HTTP::APIException => e
		if e.code == 302
			fatal 'username already taken'
		else
			fatal 'unknown error occurred'
		end
	end

	exit
end

if $options[:password]
	begin
		$session.login($options[:name], $options[:password])
	rescue Fag::HTTP::APIException => e
		if e.code == 403
			fatal 'username or password are wrong'
		else
			fatal 'could not login'
		end

		exit 23
	end
else
	$session.user.name = $options[:name] if $options[:name]
end

if $options[:show] == :home
	$options[:show] = $config['home'] || '*'
end

if !$options[:content] && $options[:new]
	unless ENV['EDITOR']
		fatal 'no editor is set, set the env var EDITOR to your favourite editor'
	end

	temp = Tempfile.new 'fag'
	
	system("$EDITOR #{temp.path}")

	$options[:content] = temp.read
end

if $options[:new]
	if $options[:for] == :flow
		begin
			flow = $session.flow($options[:for_id])
			drop = flow.create_drop $options[:content], $options[:title]

			added "drop #{drop.id.to_s.white.bold}"
		rescue Fag::HTTP::APIException => e
			fatal 'unknown error occurred'
		end
	else
		begin
			flow = $session.create_flow($options[:title], $options[:tags], $options[:content])

			added "flow #{flow.id.to_s.white.bold}"
		rescue Fag::HTTP::APIException => e
			fatal 'unknown error occurred'
		end
	end
elsif $options[:delete]
	if $options[:delete] == :drop
		begin
			drop = $session.drop($options[:delete_id]).destroy
			id   = drop.id

			deleted "drop #{id.to_s.white.bold}"
		rescue Fag::HTTP::APIException => e
			fatal 'unknown error occurred'
		end
	else
		begin
			flow = $session.flow($options[:delete_id])

			if confirm? "delete flow #{color(flow.id, :id)} titled #{color(escape(flow.title), :title)} with tags #{flow.tags.map { |t| color(t, :tag) }.join ', '} by #{color_author(flow.author)}"
				id = flow.id
				flow.destroy

				deleted "flow #{id.to_s.white.bold}"
			end
		rescue Fag::HTTP::APIException => e
			if e.code == 404
				fatal 'flow not found'
			else
				fatal 'unknown error occurred'
			end
		end
	end
elsif $options[:show]
	if matches = $options[:show].match(/^(\d+)?(?::(\d+))?$/)
		begin
			if matches[1]
				flow = $session.flow(matches[1].to_i)

				unless $options[:bare]
					print_flow(flow)
				end

				if matches[2]
					print_drop(flow.drops[matches[2].to_i - 1], $options[:bare])
				else
					flow.drops.fetch!.each {|drop|
						print_drop(drop, $options[:bare])
					}
				end
			else
				print_drop($session.drop(matches[2].to_i), $options[:bare])
			end
		rescue Fag::HTTP::APIException => e
			if e.code == 404
				fatal 'flow not found'
			else
				fatal 'unknown error'
			end
		end
	else
		flows = $session.flows($options[:show])

		if flows.empty?
			warn "no flows match #{$options[:show].to_s.white.bold}"
			
			exit 1
		end

		flows.each {|flow|
			puts " #{color(flow.id, :id)} #{vert} #{flow.tags.map { |t| color(t, :tag) }.join ', '} #{vert} #{color_author(flow.author)} #{vert} #{color(escape(flow.title), :title)}"
		}
	end
end
